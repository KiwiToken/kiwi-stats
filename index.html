<html>
  <head>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/milligram/1.2.3/milligram.min.css">
  </head>
  <body class="container" style="padding-top: 3%;">
    
    <div class="row">
      <div class="column"><h2>0xBTC</h2></div>
      <div class="column"><h3>Blockchain Statistics</h3></div>
    </div>
    <div class="row">
      <div class="column">
        <table>
          <thead> <tr> <th> </th> <th> </th> </tr> </thead>
          <tbody id="accounts"> 
            <tr><td colspan="2">Loading info from the blockchain...</td></tr> 
          </tbody>
        </table>
      </div>
    </div>
    <div class="row">
      <div class="column">Data fetched at: <span id="LastUpdatedTime">00:00:00</span></div>
    </div>

    <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="js/ethereumjs-testrpc.js"></script>
    <script type="text/javascript" src="js/ethjs.js"></script>
    <script type="text/javascript" src="js/abi.js"></script>
    
    <script type="text/javascript">
      var eth = new Eth(window.web3.currentProvider);
      var el = function(id){ return document.querySelector(id); };
      var stats_updated_count = 0;
      const _BLOCKS_PER_READJUSTMENT = 1024;
      
      if (typeof window.web3 !== 'undefined' && typeof window.web3.currentProvider !== 'undefined') {
        eth.setProvider(window.web3.currentProvider);
      } else {
        /* throw some errors here / show link to install metamask */
      }

      const token = eth.contract(tokenABI).at('0xB6eD7644C69416d67B522e20bC294A9a9B405B31');

      el('#accounts').innerHTML = '';

      stats = [
        /*Description                     promise which retuns, or null         units         multiplier  values go here*/
        ['Mining',                        null,                                 "",           1,          null     ], /* mining difficulty */
        ['Mining Difficulty',             token.getMiningDifficulty,            "",           1,          null     ], /* mining difficulty */
        ['Estimated Hashrate',            null,                                 "Mh/s",       1,          null     ], /* mining difficulty */
        ['Rewards Until Readjustment',    null,                                 "",           1,          null     ], /* mining difficulty */
        ['Last Difficulty Start Block',   token.latestDifficultyPeriodStarted,  "",           1,          null     ], /* mining difficulty */
        ['Tokens Minted',                 token.tokensMinted,                   "0xBTC",      0.00000001, null     ], /* supply */
        ['Max Supply for Current Era',    token.maxSupplyForEra,                "0xBTC",      0.00000001, null     ], /* mining */
        ['Supply Remaining in Era',       null,                                 "0xBTC",      0.00000001, null     ], /* mining */
        ['Last Eth Reward Block',         token.lastRewardEthBlockNumber,       "",           1,          null     ], /* mining */
        ['Last Eth Block',                eth.blockNumber,                      "",           1,          null     ], /* mining */
        ['Current Reward Era',            token.rewardEra,                      "/ 39",       1,          null     ], /* mining */
        //['Blocks Until Next Epoch',     null,                                 "",         1,          null     ],
        //['Last Reward',                 token.tokensMinted,                   "0xBTC",    0.00000001, null     ],
        ['Current Mining Reward',         token.getMiningReward,                "0xBTC",      0.00000001, null     ], /* mining */
        ['Epoch Count',                   token.epochCount,                     "",           1,          null     ], /* mining */
        ['Total Supply',                  token.totalSupply,                    "0xBTC",      0.00000001, null     ], /* supply */
        ['',                              null,                                 "",           1,          null     ], /* */
        ['Token Holders',                 null,                                 "holders",    1,          null     ], /* usage */
        ['Token Transfers',               null,                                 "transfers",  1,          null     ], /* usage */
        ['Total Contract Operations',     null,                                 "txs",        1,          null     ], /* usage */
        //['',                              null,                                 "0xBTC",      0.00000001, null     ], /* */
        //['TokenMiningPool.com Hashrate',  null,                                 "Mh/s",       1,          null     ], /* pool */
        //['0xBrute.com Hashrate',          null,                                 "Mh/s",       1,          null     ], /* pool */
        //['0xPool.io Hashrate',            null,                                 "Mh/s",       1,          null     ], /* pool */
        //['gpu.PiZzA Hashrate',            null,                                 "Mh/s",       1,          null     ], /* pool */
        //['0xBTCpool.com Hashrate',        null,                                 "Mh/s",       1,          null     ], /* pool */
      ];

      function getValueFromStats(name, stats) {
        value = null
        stats.forEach(function(stat){
          if (stat[0] === name) {
            value = stat[4];
          }})
        return value
      }

      function updateStatsThatHaveDependencies(stats) {
        /* estimated hashrate */
        difficulty = getValueFromStats('Mining Difficulty', stats)
        // console.log("difficulty:" + difficulty)
        hashrate = difficulty * 2**22 / 600
        hashrate /= 1000000
        el('#EstimatedHashrate').innerHTML = "<b>" + hashrate.toFixed(2) + "</b> Mh/s";

        /* supply remaining in era */
        max_supply_for_era = getValueFromStats('Max Supply for Current Era', stats)
        current_supply = getValueFromStats('Tokens Minted', stats)
        current_reward = getValueFromStats('Current Mining Reward', stats)
        // console.log("max_supply_for_era:" + max_supply_for_era)
        // console.log("current_supply:" + current_supply)
        supply_remaining_in_era = max_supply_for_era - current_supply; /* TODO: probably need to round to current mining reward */
        rewards_blocks_remaining_in_era = supply_remaining_in_era / current_reward;
        el('#SupplyRemaininginEra').innerHTML = "<b>" + supply_remaining_in_era.toString(10) + "</b> 0xBTC <span>(" + rewards_blocks_remaining_in_era + " blocks)</span>";

        /* rewards until next readjustment */
        epoch_count = getValueFromStats('Epoch Count', stats)
        rewards_left = _BLOCKS_PER_READJUSTMENT - (epoch_count % _BLOCKS_PER_READJUSTMENT)
        el('#RewardsUntilReadjustment').innerHTML = "<b>" + rewards_left.toString(10) + "</b>";

      }

      // function updateEstimatedHashrate(difficulty) {
      // }

      // function updateSupplyRemainingInEra(latestDifficultyPeriodStarted) {
      //   console.log("blocks:" + latestDifficultyPeriodStarted)
      //   el('#BlocksUntilNextEpoch').innerHTML = "<b>" + latestDifficultyPeriodStarted.toFixed(2) + "</b> Mh/s";
      // }

      function updateLastUpdatedTime() {
        var time = new Date();
        current_time = time.toLocaleTimeString();
        el('#LastUpdatedTime').innerHTML = current_time;
      }

      function updateThirdPartyAPIs() {
        /* ethplorer token info */
        $.getJSON('https://api.ethplorer.io/getTokenInfo/0xb6ed7644c69416d67b522e20bc294a9a9b405b31?apiKey=freekey', 
          function(data) {
            el('#TokenHolders').innerHTML = "<b>" + data["holdersCount"] + "</b> holders";
            el('#TokenTransfers').innerHTML = "<b>" + data["transfersCount"] + "</b> transfers";
        });
        /* ethplorer contract address info */
        $.getJSON('https://api.ethplorer.io/getAddressInfo/0xb6ed7644c69416d67b522e20bc294a9a9b405b31?apiKey=freekey', 
          function(data) {
            el('#TotalContractOperations').innerHTML = "<b>" + data["countTxs"] + "</b> txs";
        });
      }

      function createStatsTable(){
        stats.forEach(function(stat){
          stat_name = stat[0]
          stat_function = stat[1]
          stat_unit = stat[2]
          stat_multiplier = stat[3]

          el('#accounts').innerHTML += '<tr><td>'
            + stat_name + '</td><td id="'
            + stat_name.replace(/ /g,"") + '"></td></tr>';
        });
      }

      function areAllBlockchainStatsLoaded(stats) {
        all_loaded = true;

        stats.forEach(function(stat){
          stat_name = stat[0]
          stat_function = stat[1]
          stat_unit = stat[2]
          stat_multiplier = stat[3]
          stat_value = stat[4]
          /* if there is a function without an associated value, we are still waiting */
          if(stat_function !== null && stat_value === null) {
            console.log('false! value:' + stat_value)
            //console.log('false')
            all_loaded = false;
          }
          //console.log('stat check fn: ' + stat_function.toString() + " value: " + stat_value)
        })

        if(all_loaded) {
          //console.log('truetruetruetruetruetruetruetruetruetruetrue')
          return true;
        } else {
          return false;
        }
      }

      function updateStatsTable(stats){
        stats.forEach(function(stat){
          stat_name = stat[0]
          stat_function = stat[1]
          stat_unit = stat[2]
          stat_multiplier = stat[3]

          set_value = function(stats, stat_name, stat_unit, stat_multiplier, save_fn) {
            return function(result) {
              //console.log("setting " + stat_name + " with " + result + " type " + typeof result)
              try {
                result = result[0].toString(10)
              } catch (err) {
                result = result.toString(10)
              }

              // /* once we get diffuculty we can calculate est hashrate */
              // if (stat_name === "Mining Difficulty") {
              //   updateEstimatedHashrate(result)
              // }

              // /* once we get diffuculty we can calculate est hashrate 
              // if (stat_name === "Last Difficulty Start Block") {
              //   updateBlocksUntilNextEpoch(result)
              // }

              result = result.toString(10)*stat_multiplier

              save_fn(result)

              //console.log("typeof result is " + typeof result)

              console.log("set " + stat_name + " with " + result.toString(10))
              el('#' + stat_name.replace(/ /g,"")).innerHTML = "<b>" + result + "</b> " + stat_unit;

              /* once we have grabbed all stats, update the calculated ones */
              if(areAllBlockchainStatsLoaded(stats)) {
                updateStatsThatHaveDependencies(stats);
              }
            }
          }
          /* run promises that store stat values */
          if(stat_function !== null) {
            stat_function().then(set_value(stats, stat_name, stat_unit, stat_multiplier, (value) => {stat[4]=value}));
          }
        });

        updateThirdPartyAPIs();
        updateLastUpdatedTime();
      }


//       const filter = new eth.filter.Filter({ delay: 300 })
//       .new({ fromBlock: "latest" })
//       .then((result) => {
//         // result <BigNumber ...> filterId
//       })
//       .catch((error) => {
//         // result null
//       });
//       filter.watch((result) => {
//           console.log("got a block update")
//           console.log(result);
//         // result [{...}, ...] (fires multiple times)
//       });
// //filter.uninstall(cb);


      const filter = new eth.filter.BlockFilter()
      filter.watch((result) => {
        // result [{...}, ...] (fires multiple times)
          console.log("got block update")
      });
      //filter.uninstall(cb);


      // function pollForChanges(filter_id) {
      //   eth.getFilterChanges(filter_id)
      //   .then((result) => {
      //     console.log("got block update")
      //     pollForChanges()
      //   })
      // }

      createStatsTable();
      updateStatsTable(stats);
      //setupNewBlockFilter();

      // eth.newBlockFilter()
      // .then((result) => {
      //   console.log("got filter")
      //   console.log(result);
      //   filter_id = result[0]
      //   //updateStatsTable();
      //   console.log("res")
      //   console.log(filter_id)
      //   pollForChanges(filter_id);
      // })
      // .catch((error) => {
      //   console.log("got a block update error")
      //   // null
      // });


      // eth.newBlockFilter()
      // .then((result) => {
      //   console.log("got a block update")
      //   updateStatsTable();
      // })
      // .catch((error) => {
      //   // null
      // });

      // eth.accounts(function(accountsError, accounts) {
      //   if (accountsError) {
      //     el('#accounts').innerHTML = 'Hmm.. looks like there was an error: '
      //       + String(accountsError);
      //   }


      //   accounts.forEach(function(account){
      //     el('#accounts').innerHTML += '<tr><td>'
      //       + account + '</td><td id="accountBalance_'
      //       + account + '"></td></tr>';

      //     eth.getBalance(account, function(balanceError, balance){
      //       el('#accountBalance_' + account).innerHTML += Eth.fromWei(balance, 'ether')
      //         + ' ether';
      //     });
      //   });
      // });
    </script>
  </body>
</html>
